apiVersion: opentelemetry.io/v1beta1
kind: OpenTelemetryCollector
metadata:
  name: otel-daemonset
spec:
  mode: daemonset
  serviceAccount: otel-daemonset-collector
  volumeMounts:
    - name: hostfs
      mountPath: /hostfs
      readOnly: true
  volumes:
    - name: hostfs
      hostPath:
        path: /
  env:
    - name: NODE_IP
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: status.hostIP
    - name: KUBE_NODE_NAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName
    - name: K8S_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
    - name: K8S_POD_NAME
      valueFrom:
        fieldRef:
          fieldPath: metadata.name
    - name: NEW_RELIC_LICENSE_KEY
      valueFrom:
        secretKeyRef:
          name: newrelic-license
          key: license-key
    - name: CLUSTER_NAME
      value: homelab
  config:
    receivers:
      hostmetrics:
        root_path: /hostfs
        collection_interval: 1m
        scrapers:
          cpu:
            metrics:
              system.cpu.time:
                enabled: false
              system.cpu.utilization:
                enabled: true
              system.cpu.logical.count:
                enabled: true
          memory:
            metrics:
              system.memory.utilization:
                enabled: true
          network:
            metrics:
              system.network.connections:
                enabled: false
          load:
          paging:
            metrics:
              system.paging.utilization:
                enabled: false
              system.paging.faults:
                enabled: false
          filesystem:
            metrics:
              system.filesystem.utilization:
                enabled: true
            exclude_mount_points:
              mount_points:
                - ^/var/lib/containers/storage/overlay$
              match_type: regexp
          disk:
            metrics:
              system.disk.merged:
                enabled: false
              system.disk.pending_operations:
                enabled: false
              system.disk.weighted_io_time:
                enabled: false
          processes:
          process:
            metrics:
              process.cpu.utilization:
                enabled: true
              process.cpu.time:
                enabled: false
            mute_process_name_error: true
            mute_process_exe_error: true
            mute_process_io_error: true
            mute_process_user_error: true

      prometheus:
        config:
          scrape_configs:
            - job_name: cadvisor
              scrape_interval: 1m
              bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
              kubernetes_sd_configs:
                - role: node
              relabel_configs:
                - replacement: kubernetes.default.svc.cluster.local:443
                  target_label: __address__
                - regex: (.+)
                  replacement: /api/v1/nodes/$$1/proxy/metrics/cadvisor
                  source_labels:
                    - __meta_kubernetes_node_name
                  target_label: __metrics_path__
                - action: replace
                  target_label: job_label
                  replacement: cadvisor
                - source_labels: [__meta_kubernetes_node_name]
                  regex: ${KUBE_NODE_NAME}
                  action: keep
              scheme: https
              tls_config:
                ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                insecure_skip_verify: false
                server_name: kubernetes

            - job_name: kubelet
              scrape_interval: 1m
              bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
              kubernetes_sd_configs:
                - role: node
              relabel_configs:
                - replacement: kubernetes.default.svc.cluster.local:443
                  target_label: __address__
                - regex: (.+)
                  replacement: /api/v1/nodes/$$1/proxy/metrics
                  source_labels:
                    - __meta_kubernetes_node_name
                  target_label: __metrics_path__
                - action: replace
                  target_label: job_label
                  replacement: kubelet
                - source_labels: [__meta_kubernetes_node_name]
                  regex: ${KUBE_NODE_NAME}
                  action: keep
              scheme: https
              tls_config:
                ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                insecure_skip_verify: false
                server_name: kubernetes

      kubeletstats:
        collection_interval: 1m
        endpoint: "${env:NODE_IP}:10250"
        auth_type: "serviceAccount"
        insecure_skip_verify: true
        metrics:
          k8s.container.cpu_limit_utilization:
            enabled: true
          k8s.pod.cpu_limit_utilization:
            enabled: true
          k8s.pod.cpu_request_utilization:
            enabled: true
          k8s.pod.memory_limit_utilization:
            enabled: true
          k8s.pod.memory_request_utilization:
            enabled: true

    processors:
      memory_limiter:
        check_interval: 1s
        limit_percentage: 80
        spike_limit_percentage: 25

      resourcedetection/env:
        detectors: ["env", "system"]
        override: false
        system:
          hostname_sources: ["os"]
          resource_attributes:
            host.name:
              enabled: true

      # Group system.cpu metrics by cpu
      metricstransform/hostmetrics_cpu:
        transforms:
          - include: system.cpu.utilization
            action: update
            operations:
              - action: aggregate_labels
                label_set: [state]
                aggregation_type: mean
          - include: system.paging.operations
            action: update
            operations:
              - action: aggregate_labels
                label_set: [direction]
                aggregation_type: sum

      # Drop noisy CPU states: interrupt, nice, softirq
      filter/exclude_cpu_utilization:
        metrics:
          datapoint:
            - 'metric.name == "system.cpu.utilization" and attributes["state"] == "interrupt"'
            - 'metric.name == "system.cpu.utilization" and attributes["state"] == "nice"'
            - 'metric.name == "system.cpu.utilization" and attributes["state"] == "softirq"'

      # Drop noisy memory utilization states
      filter/exclude_memory_utilization:
        metrics:
          datapoint:
            - 'metric.name == "system.memory.utilization" and attributes["state"] == "slab_unreclaimable"'
            - 'metric.name == "system.memory.utilization" and attributes["state"] == "inactive"'
            - 'metric.name == "system.memory.utilization" and attributes["state"] == "cached"'
            - 'metric.name == "system.memory.utilization" and attributes["state"] == "buffered"'
            - 'metric.name == "system.memory.utilization" and attributes["state"] == "slab_reclaimable"'

      # Drop noisy memory usage states
      filter/exclude_memory_usage:
        metrics:
          datapoint:
            - 'metric.name == "system.memory.usage" and attributes["state"] == "slab_unreclaimable"'
            - 'metric.name == "system.memory.usage" and attributes["state"] == "inactive"'

      # Drop squashfs filesystem utilization
      filter/exclude_filesystem_utilization:
        metrics:
          datapoint:
            - 'metric.name == "system.filesystem.utilization" and attributes["type"] == "squashfs"'

      # Drop squashfs filesystem usage and reserved state
      filter/exclude_filesystem_usage:
        metrics:
          datapoint:
            - 'metric.name == "system.filesystem.usage" and attributes["type"] == "squashfs"'
            - 'metric.name == "system.filesystem.usage" and attributes["state"] == "reserved"'

      # Drop squashfs filesystem inodes usage and reserved state
      filter/exclude_filesystem_inodes_usage:
        metrics:
          datapoint:
            - 'metric.name == "system.filesystem.inodes.usage" and attributes["type"] == "squashfs"'
            - 'metric.name == "system.filesystem.inodes.usage" and attributes["state"] == "reserved"'

      # Drop loop devices from disk metrics
      filter/exclude_system_disk:
        metrics:
          datapoint:
            - 'metric.name == "system.disk.operations" and IsMatch(attributes["device"], "^loop.*") == true'
            - 'metric.name == "system.disk.io" and IsMatch(attributes["device"], "^loop.*") == true'
            - 'metric.name == "system.disk.io_time" and IsMatch(attributes["device"], "^loop.*") == true'
            - 'metric.name == "system.disk.operation_time" and IsMatch(attributes["device"], "^loop.*") == true'

      # Drop cached paging state
      filter/exclude_system_paging:
        metrics:
          datapoint:
            - 'metric.name == "system.paging.usage" and attributes["state"] == "cached"'
            - 'metric.name == "system.paging.operations" and attributes["type"] == "cached"'

      # Remove "type" attribute from paging operations (after filtering)
      attributes/exclude_system_paging:
        include:
          match_type: strict
          metric_names:
            - system.paging.operations
        actions:
          - key: type
            action: delete

      # Drop loopback device from network metrics
      filter/exclude_network:
        metrics:
          datapoint:
            - 'IsMatch(metric.name, "^system.network.*") == true and attributes["device"] == "lo"'

      # K8s attributes processor: enrich metrics with Kubernetes metadata (node-local)
      k8sattributes:
        auth_type: "serviceAccount"
        passthrough: false
        filter:
          node_from_env_var: KUBE_NODE_NAME
        extract:
          metadata:
            - k8s.pod.name
            - k8s.pod.uid
            - k8s.deployment.name
            - k8s.daemonset.name
            - k8s.namespace.name
            - k8s.node.name
            - k8s.pod.start_time
            - k8s.replicaset.name
            - k8s.statefulset.name
            - k8s.cronjob.name
            - k8s.job.name
        pod_association:
          - sources:
              - from: resource_attribute
                name: k8s.pod.uid
          - sources:
              - from: resource_attribute
                name: k8s.pod.name

      # Resource attributes: cluster name, NR flags, and service name cleanup
      resource:
        attributes:
          - key: k8s.cluster.name
            action: upsert
            value: ${CLUSTER_NAME}
          - key: newrelicOnly
            action: upsert
            value: 'true'
          - key: service.name
            action: delete
          - key: service_name
            action: delete

      batch:
        send_batch_max_size: 1000
        timeout: 30s
        send_batch_size: 800

    exporters:
      otlphttp/newrelic:
        endpoint: https://otlp.nr-data.net
        headers:
          X-License-Key: ${env:NEW_RELIC_LICENSE_KEY}

      debug:
        verbosity: detailed

    service:
      pipelines:
        metrics:
          receivers:
            - hostmetrics
            - prometheus
            - kubeletstats
          processors:
            - memory_limiter
            - metricstransform/hostmetrics_cpu
            - filter/exclude_cpu_utilization
            - filter/exclude_memory_utilization
            - filter/exclude_memory_usage
            - filter/exclude_filesystem_utilization
            - filter/exclude_filesystem_usage
            - filter/exclude_filesystem_inodes_usage
            - filter/exclude_system_disk
            - filter/exclude_system_paging
            - filter/exclude_network
            - attributes/exclude_system_paging
            - resourcedetection/env
            - k8sattributes
            - resource
            - batch
          exporters:
            - otlphttp/newrelic
            # - debug
